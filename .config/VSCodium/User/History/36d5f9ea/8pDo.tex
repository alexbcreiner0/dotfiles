\documentclass{beamer}

\usepackage{fancyvrb}
\makeatletter
\def\KV@FV@lastline@default{%
  \let\FancyVerbStopNum\m@ne
  \let\FancyVerbStopString\relax}
\fvset{lastline}
\makeatother
\usepackage{listings}
\usepackage{minted}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{bm}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\urlstyle{same}
\usetheme{Madrid}

\title{Complexity Theory and NP-Completeness}
\author{Alex Creiner}

\institute{Boston College}
\date{Spring 2024}

\begin{document}

\titlepage
\begin{frame}{Introduction}
    \begin{itemize}
        \item We now turn towards a brief overview of complexity theory more broadly, with the nominal purpose of noting a particular set of especially difficult problems, and how to tell if the problem you are trying to solve is one of them. 
        \item If this material interests you, consider taking my complexity theory elective next spring! 
    \end{itemize}
\end{frame}

\begin{frame}{Decision Problems}
    \begin{itemize}
        \item For the sake of simplicity, computational complexity theorists generally focus on a specific kind of problem known as a \textbf{decision problem}. A decision problem is a problem in which the answer is always a Boolean value: Yes or no, true or false, etc. \pause 
        \item Examples:
        \begin{itemize}
            \item The factoring problem: Given an integer $x$, does it have a non-trivial prime factor? (Non-trivial means not $1$) \pause 
            \item The satisfiability problem (SAT): Given a Boolean expression with $n$ many variables $\phi$, does there exist an assignment of truth values to those variables which makes the expression evaluate to true? (For example, $(x_1 \wedge x_2)\vee \neg x_3$ is satisfiable by setting $x_1$ and $x_2$ equal to True, and $x_3$ equal to false). \pause
            \item The graph isomorphism problem: Given two graphs, is one actually just a relabelling of the nodes of the other? \pause 
        \end{itemize}
        \item The middle of these, $SAT$, is particularly important to us. Don't forget about it. 
    \end{itemize}
\end{frame}

\begin{frame}{Decision Problems}
    \begin{itemize}
        \item Most non-decision problems have a decision problem which can be expressed in place of it, which encapsulates the complexity of the original. \pause 
        \item For example, the travelling salesman problem (TSP) is an optimization problem: Given a complete weighted graph, what is the shortest path which touches every node exactly once? \pause
        \item The decision problem `version' of this is the problem: Given a complete weighted graph and a length $d$, does there exist a path which reaches every node exactly once and which has total length $\leq d$? \pause 
        \item Through the magic of binary search, a solution to the decision problem version of TSP can be utilized to produce a solution to the original optimization question without much time overhead. \pause 
        \item In this way, we should see decision problems as standing in for all other kinds of problems in order to simplify the discussion. 
    \end{itemize}
\end{frame}

\begin{frame}{Some basic complexity classes: \textbf{R}}
    \begin{itemize}
        \item We can now define some basic complexity classes. 
        \item First, we've already briefly mentioned the set of all computable decision problems, $\mathbf{R}$. This is actually a tiny subset of the universe of all decision problems; most problems are \emph{not} computable at all! \pause 
        \item A famous example is the halting problem: Given the code for a computer program and an input to it, will the program ever halt on that input? (I.e. will there not be an infinite loop of some sort?) 
        \item When I teach logic and computation, I always make it a goal to prove that this problem is not computable. 
    \end{itemize}
\end{frame}

\begin{frame}{Some basic complexity classes \textbf{P} and \textbf{EXP}}
    \begin{itemize}
        \item Next, the class $\mathbf{P}$ is the set of all problems which are computable in \textbf{polynomial time}. I.e. a decision problem $L$ is in $\mathbf{P}$ iff there is an algorithm which solves it in time $O(n^k)$ for some $k \in \mathbb{Z}$. 
        \item We've spent the entire class so far safe and cozy within this class. Most of our algorithms usually end up operating in time $O(n^2)$, or $O(n\log(n))$, or $O(n^3)$, etceteral. These are all in $\mathbf{P}$. 
        \item On the other hand, $\mathbf{EXP}$ is the set of problems which are computable in $\textbf{exponential time}$, i.e. time $O(2^{n^k})$ for some $k \in \mathbb{Z}$. 
        \item Since any polynomial time is also exponential time, $\mathbf{P} \subseteq \mathbf{EXP}$. It follows that anything proven to be in $\mathbf{EXP}$ but not in $\mathbf{P}$ could be labelled as an exceptionally difficult problem. Are there any known examples?
    \end{itemize}
\end{frame}

\begin{frame}{Complexity classes continued}
    \begin{itemize}
        \item Plenty! My personal go-to example is generalized chess. Given an $n \times n$ chess board and some configuration of the pieces on that board, does player $1$ have a winning strategy? I.e. is there a move that player $1$ can make so that no matter what move player $2$ makes, there is a move that player $1$ can make so that no matter what move player $2$ makes... etc, until player $1$ wins?
    \end{itemize}
\end{frame}

\end{document}