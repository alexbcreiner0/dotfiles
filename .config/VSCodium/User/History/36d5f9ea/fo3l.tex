\documentclass{beamer}

\usepackage{fancyvrb}
\makeatletter
\def\KV@FV@lastline@default{%
  \let\FancyVerbStopNum\m@ne
  \let\FancyVerbStopString\relax}
\fvset{lastline}
\makeatother
\usepackage{listings}
\usepackage{minted}
\usepackage{tikz}
\usepackage{graphicx}
\usepackage{bm}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\urlstyle{same}
\usetheme{Madrid}

\title{Complexity Theory and NP-Completeness}
\author{Alex Creiner}

\institute{Boston College}
\date{Spring 2024}

\begin{document}

\titlepage
\begin{frame}{Introduction}
    \begin{itemize}
        \item We now turn towards a brief overview of complexity theory more broadly, with the nominal purpose of noting a particular set of especially difficult problems, and how to tell if the problem you are trying to solve is one of them. 
        \item If this material interests you, consider taking my complexity theory elective next spring! 
    \end{itemize}
\end{frame}

\begin{frame}{Decision Problems}
    \begin{itemize}
        \item For the sake of simplicity, computational complexity theorists generally focus on a specific kind of problem known as a \textbf{decision problem}. A decision problem is a problem in which the answer is always a Boolean value: Yes or no, true or false, etc. \pause 
        \item Examples:
        \begin{itemize}
            \item The factoring problem: Given an integer $x$, does it have a non-trivial prime factor? (Non-trivial means not $1$) \pause 
            \item The satisfiability problem (SAT): Given a Boolean expression with $n$ many variables $\phi$, does there exist an assignment of truth values to those variables which makes the expression evaluate to true? (For example, $(x_1 \wedge x_2)\vee \neg x_3$ is satisfiable by setting $x_1$ and $x_2$ equal to True, and $x_3$ equal to false). \pause
            \item The graph isomorphism problem: Given two graphs, is one actually just a relabelling of the nodes of the other? \pause 
        \end{itemize}
        \item The middle of these, $SAT$, is particularly important to us. Don't forget about it. 
    \end{itemize}
\end{frame}

\begin{frame}{Decision Problems}
    \begin{itemize}
        \item Most non-decision problems have a decision problem which can be expressed in place of it, which encapsulates the complexity of the original. \pause 
        \item For example, the travelling salesman problem (TSP) is an optimization problem: Given a complete weighted graph, what is the shortest path which touches every node exactly once? \pause
        \item The decision problem `version' of this is the problem: Given a complete weighted graph and a length $d$, does there exist a path which reaches every node exactly once and which has total length $\leq d$? \pause 
        \item Through the magic of binary search, a solution to the decision problem version of TSP can be utilized to produce a solution to the original optimization question without much time overhead. \pause 
        \item In this way, we should see decision problems as standing in for all other kinds of problems in order to simplify the discussion. 
    \end{itemize}
\end{frame}

\begin{frame}{Some basic complexity classes}
    \begin{itemize}
        \item We can now define some basic complexity classes. 
        \item First, we've already briefly mentioned the set of all computable decision problems, $\mathbf{R}$. This is actually a tiny subset of the universe of all decision problems; most problems are \emph{not} computable at all! \pause 
        \item A famous example is the halting problem: Given the code for a computer program and an input to it, will the program ever halt on that input? (I.e. will there not be an infinite loop of some sort?) When I teach logic and computation, I always make it a goal to prove that this problem is not computable. 
    \end{itemize}
\end{frame}

\end{document}