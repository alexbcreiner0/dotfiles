\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{enumitem}  %this permits the enumeration items to flow past sections


\title{Algorithms - Assignment 7}
\date{Due }

\begin{document}
\maketitle

\begin{enumerate}
    \item[(1)] Let $A$ be an array of integers. We wish to find a subarray $A[i:j]$ (i.e. a subarray of consecutive elements from $A$, sometimes referred to as a 
    emph{contiguous subsequence}) such that when we sum those entries, we get the largest possible sum. For example, if $A=[-2, 1, -3, 4, -1, 2, 1, -5, 4]$, then a contiguous subarray with the maximum sum is $[4,-1,2,1]$, whose elements sum to $6$.
    \begin{itemize}
        \item[(a)] Describe and implement a brute-force solution to the problem. What is the runtime? 
        \item[(b)] Describe a dynamic programming solution which operates in linear time. Your description needs to clearly define the subproblems, express a recurrence relation between the problem and those subproblems, and clearly state what is being done in order to construct the solution (i.e. what we are maximizing, minimizing, etc). You should also justify the runtime. 
        \item[(c)] Implement the solution in Python. Your solution can be top down or bottom up, and doesn't need to return the actual subsequence, just the maximum sum. 
    \end{itemize}
    \item[(2)] You are given a string of n characters $s[1,\ldots,n]$ which you believe to be a corrupted text document in which all punctuation has vanished (so it looks something like `thetraditionofalldeadgenerationsweighslikeanightmareonthemindsoftheliving'). You wish to reconstruct the document using a dictionary. We can do this (badly) in python using the natural language toolkit library. Do a pip install nltk in your terminal, and then copy-paste the following code: 
    \begin{minted}{python}
    import nltk
    nltk.download('words')
    from nltk.corpus import words

    english_words = set(words.words())

    def d(word):
	    if len(word) == 1:
		    if word.lower() != 'a' and word.lower() != 'i': return False
	    return word.lower() in english_words
    \end{minted}
    This gives you a function d(s), which (mostly) returns True if s is a word in the English dictionary and False if it's not. I say mostly because it seems pretty finicky. It counts every 1 letter string as a valid word, and also seems to disqualify certain plural words as not words (for example in the above example string, it thinks `weighs' isn't a word). Whatever. It's good enough for our testing purposes. 

\end{enumerate}

\end{document}