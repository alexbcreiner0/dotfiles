\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{enumitem}  %this permits the enumeration items to flow past sections


\title{Algorithms - Assignment 7}
\date{Due }

\begin{document}
\maketitle

\begin{enumerate}
    \item[(1)] Let $A$ be an array of integers. We wish to find a subarray $A[i:j]$ (i.e. a subarray of consecutive elements from $A$, sometimes referred to as a 
    emph{contiguous subsequence}) such that when we sum those entries, we get the largest possible sum. For example, if $A=[-2, 1, -3, 4, -1, 2, 1, -5, 4]$, then a contiguous subarray with the maximum sum is $[4,-1,2,1]$, whose elements sum to $6$.
    \begin{itemize}
        \item[(a)] Describe and implement a brute-force solution to the problem. What is the runtime? 
        \item[(b)] Describe a dynamic programming solution which operates in linear time. Your description needs to clearly define the subproblems, express a recurrence relation between the problem and those subproblems, and clearly state what is being done in order to construct the solution (i.e. what we are maximizing, minimizing, etc). You should also justify the runtime. 
        \item[(c)] Implement the solution in Python. Your solution can be top down or bottom up, and doesn't need to return the actual subsequence, just the maximum sum. 
    \end{itemize}
    \item[(2)] You are given a string of n characters $s[1,\ldots,n]$ which you believe to be a corrupted text document in which all punctuation has vanished (so it looks something like `thetraditionofalldeadgenerationsweighslikeanightmareonthemindsoftheliving'). You wish to reconstruct the document using a dictionary. To get a dictionary (mostly) working in python, we'll use the natural language toolkit package. Do a pip install nltk in your terminal, and then copy-paste the following code to wherever you plan on solving this problem: 
    \begin{minted}{python}
import nltk
nltk.download('words')
from nltk.corpus import words

english_words = set(words.words())

def d(word):
    if len(word) == 1:
	    if word.lower() != 'a' and word.lower() != 'i': return False
    return word.lower() in english_words
    \end{minted}
    This gives you a function d(s), which (mostly) returns True if s is a word in the English dictionary and False if it's not. I say mostly because it's pretty finicky. It counts every one letter string as a valid word (why I had to add the if statement in the function), and also seems to disqualify certain plural words as not words (for example in the above example string, it thinks `weighs' isn't a word). Whatever. It's good enough for our testing purposes. \par 
    \begin{itemize}
        \item[(a)] Describe a dynamic programming algorithm that determines whether the string s can be reconstituted as a sequence of valid words. Your explanation should clearly define the subproblems, express a recurrence relation relating a problem to it's subproblems, and explain how this relationship would be used in a solution. The running time should be at most $O(n^3)$ on the assumption that calls to the $d$ function above are constant time. (Hint: Use the edit distance example as a model for how to approach this.)
        \item[(b)] Write the dynamic program in python. I recommend going with a bottom-up implementation, but it does not matter. We will test your code on a few strings that are two or three words, such as `dogstorm' and `catviper'.
    \end{itemize}

\end{enumerate}

\end{document}