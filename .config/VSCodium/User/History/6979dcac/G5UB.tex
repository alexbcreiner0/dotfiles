\documentclass[12pt]{article}
\usepackage[margin=1in]{geometry}
\usepackage{listings}
\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{fancyvrb}
\usepackage{minted}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{enumitem}  %this permits the enumeration items to flow past sections


\title{Algorithms - Assignment 7}
\date{Due }

\begin{document}
\maketitle

\begin{enumerate}
    \item[(1)] Let $A$ be an array of integers. We wish to find a subarray $A[i:j]$ (i.e. a subarray of consecutive elements from $A$, sometimes referred to as a 
    emph{contiguous subsequence}) such that when we sum those entries, we get the largest possible sum. For example, if $A=[-2, 1, -3, 4, -1, 2, 1, -5, 4]$, then a contiguous subarray with the maximum sum is $[4,-1,2,1]$, whose elements sum to $6$.
    \begin{itemize}
        \item[(a)] Describe and implement a brute-force solution to the problem. What is the runtime? 
        \item[(b)] Describe a dynamic programming solution which operates in linear time. Your description needs to clearly define the subproblems, express a recurrence relation between the problem and those subproblems, and clearly state what is being done in order to construct the solution (i.e. what we are maximizing, minimizing, etc). You should also justify the runtime. 
        \item[(c)] Implement the solution in Python. Your solution can be top down or bottom up, and doesn't need to return the actual subsequence, just the maximum sum. 
    \end{itemize}
    \item[(2)] You are given a string of n characters $s[1,\ldots,n]$ which you believe to be a corrupted text document in which all punctuation has vanished (so it looks something like `thetraditionofalldeadgenerationsweighslikeanightmareonthemindsoftheliving'). You wish to reconstruct the document using a dictionary. To get a dictionary (mostly) working in python, we'll use the natural language toolkit package. Do a pip install nltk in your terminal, and then copy-paste the following code to wherever you plan on solving this problem: 
    \begin{minted}{python}
import nltk
nltk.download('words')
from nltk.corpus import words

english_words = set(words.words())

def d(word):
    if len(word) == 1:
	    if word.lower() != 'a' and word.lower() != 'i': return False
    return word.lower() in english_words
    \end{minted}
    This gives you a function d(s), which (mostly) returns True if s is a word in the English dictionary and False if it's not. I say mostly because it's pretty finicky. It counts every one letter string as a valid word (why I had to add the if statement in the function), and also seems to disqualify certain plural words as not words (for example, in the above example string, it thinks `weighs' isn't a word, yet has no problem with the word `generations'). Whatever. It's good enough for our testing purposes. We just want a way to check if our code (mostly) works. \par 
    \begin{itemize}
        \item[(a)] Describe a dynamic programming algorithm that determines whether the string s can be reconstituted as a sequence of valid words. Your explanation should clearly define the subproblems, express a recurrence relation relating a problem to it's subproblems, and explain how this relationship would be used in a solution. The running time should be at most $O(n^3)$ on the assumption that calls to the $d$ function above are constant time. (Hint: Use the edit distance example as a model for how to approach this.)
        \item[(b)] Write the dynamic program in python. I recommend going with a bottom-up implementation, but it does not matter. We will test your code on a few strings that are two or three words long each, such as `dogstorm' and `catviper'.
    \end{itemize}
    \item[(3)] We described in class a dynamic programming algorithm which could find shortest paths of particular lengths. In particular, we noted that for a weighted graph $G=(V,E,w)$ and a given starting node $s$, if $SP(v,i)$ is the shortest path from $s$ to $v$ which traverses exactly $i$ many edges, then 
     \[ SP(v,i) = \min_{(u,v) \in E}(SP(u,i-1)+w(u,v)) \] 
     This implies a dynamic program for finding shortest paths. We also noted in class that this program had a suspiciously familiar runtime: $O(|V||E|)$ - the same as Bellman Ford. In this exercise you will investigate that relationship and see that these are really just the top down and bottom up versions of the same dynamic programming algorithm.
     \begin{itemize}
        \item[(a)] Implement this dynamic program for shortest paths from the top down in python. The keys of your memo dictionary should be 2-tuples $(u,i)$, where $u$ is a node of the graph and $i$ is a number of edges traversed (ranging between $0$ and $|V|$). Make sure to initialize your memo so that $(s,0) = 0$, and $(u,0) = \inf$ for all other nodes $u \neq s$. Your program can either return the entire subproblem dictionary, but for the purposes of comparing it to your Bellman Ford algorithm from the previous homework, you should also add an option which takes the minimum distance from $s$ to every other node out of all possible $i$'s in order to return an output that is hopefully the same as your Bellman-Ford function. Use both algorithms on the example graph from the previous assignment (the one linked on the canvas page under the assignment) to confirm that your implementation works.
        \item[(b)] Run some tests of your top-down dynamic program against Bellman-Ford and show that they have comparable runtimes, and include a matplotlib plot in your write-up. You can use the same random graph function from the previous assignment. Don't go too crazy with the sample size; just range $n$ from $20$ to $130$ with a step size of $2$ or something like that. Your top-down should be a decent amount slower, although both are still slow as molasses compared to Dijkstra. \
        \item[(c)] We never mentioned when discussing Bellman-Ford that it was capable of returning shortest paths of a specific number of edge `hops'. To show yourself how the original Bellman-Ford algorithm is really a bottom up DP, explain how you could modify it to return shortest paths that traverse exactly $i$ edges for a given $i$. (Hint: Our original Bellman-Ford performs it's outer loop $|V|$ many times. Can you identify a loop invariant?) 
     \end{itemize}
\end{enumerate}

\end{document}