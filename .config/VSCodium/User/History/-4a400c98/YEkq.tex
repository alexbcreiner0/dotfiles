\documentclass{beamer}

\usepackage{fancyvrb}
\makeatletter
\def\KV@FV@lastline@default{%
  \let\FancyVerbStopNum\m@ne
  \let\FancyVerbStopString\relax}
\fvset{lastline}
\makeatother
\usepackage{listings}
\usepackage{minted}
\usepackage{tikz}
\usepackage{graphicx}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    filecolor=magenta,      
    urlcolor=cyan,
    pdftitle={Overleaf Example},
    pdfpagemode=FullScreen,
    }

\urlstyle{same}
\usetheme{Madrid}

\title{Dynamic Programming}
\subtitle{Finally taming recursion for good}
\author{Alex Creiner}

\institute{Boston College}
\date{Spring 2024}

\begin{document}

\titlepage
\begin{frame}[fragile]{Fibonacci Function Revisited}
    \begin{itemize}
        \item Recall where we left off in the beginning of class when we discussed the Fibonacci sequence. The sequence was defined recursively:
        \begin{align*}
            F_{n}= \begin{cases} 0 & \textrm{if } n = 0 \\ 1 & \textrm{if } n = 1 \\ F_{n-1} + F_{n-2} & else \end{cases} 
        \end{align*}
        \item As always, a recursive mathematical definition always immediately implies a recursive algorithm:
    \end{itemize}
    \begin{minted}{python3}
        def fib(n):
	    if n == 0: return 0
            if n == 1: return 1
            return fib(n-1) + fib(n-2)
    \end{minted}
\end{frame}

\begin{frame}{Fibonacci Function Revisited}
    \begin{itemize}
        \item However, we saw that this algorithm gets out of control rather quickly, and that this solution to the problem as is was exponential runtime. But does it have to be? (Continue on board) \pause 
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Memoized Fibonacci}
    \begin{minted}{python3}
        def memoized_fib(n):
            def memoized_fib_aux(n, memo):
                if memo[n-1] == -1:
                    memo[n-1] = memoized_fib_aux(n-1, memo)
                if memo[n-2] == -1:
                    memo[n-2] = memoized_fib_aux(n-2, memo)
                return memo[n-1] + memo[n-2]

            if n == 0: return 0
            if n == 1: return 1
            memo = [-1]*n 
            return memoized_fib_aux(n, memo)
    \end{minted}
\end{frame}

\begin{frame}[fragile]{Pythonized memoization}
    \begin{itemize}
        \item If auxiliary functions aren't your thing, you can instead make use of python's default arguments instead:
    \end{itemize}
    \begin{minted}{python3}
    def pythonized_memo_fib(n, memo = None):
        if n == 0: return 0
        if n == 1: return 1
        if memo == None:
            memo = [-1]*n
            memo[0], memo[1] = 0,1

        if memo[n-1] == -1:
            memo[n-1] = pythonized_memo_fib(n-1, memo)
        if memo[n-2] == -1:
            memo[n-2] = pythonized_memo_fib(n-1, memo)

        return memo[n-1] + memo[n-2]
    \end{minted}
\end{frame}

\begin{frame}{Top down vs bottom up}
    \begin{itemize}
        \item Since what we're doing here literally is depth first search through a dependency dag, we know that the runtime of the algorithm is $O(|V| + |E|)$. What are $|V|$ and $|E|$ though? \pause 
        \begin{itemize}
            \item $V$, our vertices.\pause We have one for each Fibonacci number before and including the one we are calculating, so $|V| = n+1$. \pause 
            \item $E$, the edges.\pause There are exactly two outgoing edges for every node in our dag \emph{except} for the two base cases, which have none. So $|E| = 2(n-2)$. \pause 
            \item We thus have that $O(|V| + |E|) = O(n+1+2(n-2)) = O(n)$. Linear time! \pause 
        \end{itemize}
        \item This is an extremely dramatic reduction in runtime, but it shouldn't surprise us. After all, we can calculate Fibonacci numbers ourselves in linear time! How is this done? \pause 
        \item Answer: We build our way \emph{up} from the base cases to the number we want. 
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Top down vs bottom up}
    \begin{itemize}
        \item More generally, we \emph{topologically sort} the dependency dag, and then proceed to calculate the numbers in that sorted order! \pause 
        \item Think about it. We write the numbers \emph{in order}, either in our heads or on paper: $0,1,1,2,3,5,8,\ldots$. What does this even mean, \emph{in order}?
        \item It means we start with $fib(0)$ and $fib(1)$, which we said are sources. Then we write $fib(2)$, which we can because it only needs $fib(2)$ and $fib(1)$, which we have already. Then we write $fib(3)$, which only needs $fib(2)$ and $fib(1)$, which we have already. And so on. \pause 
        \item In this case, the topological sorting is obvious. In general it's not always so easy, as we'll see. \pause 
        \item The memoized solution is also referred to as a \emph{top down} solution.  
    \end{itemize}
\end{frame}

\begin{frame}[fragile]{Bottom up solution}
    \begin{minted}{python3}
        def bottom_up_fib(n):
	    if n == 0: return 0
	    if n == 1: return 1
	    memo = [-1]*(n+1)
	    memo[0], memo[1] = 0,1
	    for i in range(2,n+1):
		    memo[i] = memo[i-1]+memo[i-2]
	
    	return memo[n]
    \end{minted}
\end{frame}

\end{document}